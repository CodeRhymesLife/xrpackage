<!doctype html>
<html>
<body>
<script type=module>
import * as THREE from './xrpackage/three.module.js';
import {hijackCanvas, getExports} from './xrpackage/Graphics.js';
import * as XR from './xrpackage/XR.js';
import GlobalContext from './xrpackage/GlobalContext.js';

hijackCanvas();
const {CanvasRenderingContext2D, WebGLRenderingContext, WebGL2RenderingContext} = getExports();

const xrOffsetMatrix = new THREE.Matrix4();
GlobalContext.getXrOffsetMatrix = () => xrOffsetMatrix;
GlobalContext.xrFramebuffer = null;

console.log('iframe script');
(() => {
function makePromise() {
  let resolve, reject;
  const result = new Promise((a, b) => {
    resolve = a;
    reject = b;
  });
  result.resolve = resolve;
  result.reject = reject;
  return result;
};

class XRPackageManager extends EventTarget {
  constructor() {
    super();

    this.session = null;
    this.schema = null;

    this.loadPromise = makePromise();
    this.seenEvents = {};
  }
  async iframeInit({engine, indexHtml, context, id, schema, xrState}) {
    console.log('iframe init');

    {
      const res = await fetch('/xrpackage/registerClient', {
        method: 'POST',
        body: JSON.stringify({
          id,
        }),
      });
      await res.blob();
    }

    document.open();
    document.write(indexHtml);
    document.close();

    this.schema = schema;

    GlobalContext.xrState = xrState;
    /* GlobalContext.xrFramebuffer = context.createFramebuffer();
    const fboTex = context.createTexture();
    context.bindTexture(context.TEXTURE_2D, fboTex);
    const size = 256;
    context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, size, size, 0, context.RGBA, context.UNSIGNED_BYTE, null);
    context.bindFramebuffer(context.FRAMEBUFFER, GlobalContext.xrFramebuffer);
    context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.TEXTURE_2D, fboTex, 0); */
    GlobalContext.proxyContext = context;
    GlobalContext.contexts = [];
    
    window.requestAnimationFrame = fn => engine.requestAnimationFrame(fn, globalThis);
    window.cancelAnimationFrame = engine.cancelAnimationFrame.bind(engine);
    // window.innerWidth = canvas.width;
    // window.innerHeight = canvas.height;

    window.CanvasRenderingContext2D = CanvasRenderingContext2D;
    window.WebGLRenderingContext = WebGLRenderingContext;
    window.WebGL2RenderingContext = WebGL2RenderingContext;

    const session = new XR.XRSession();
    session.onrequestanimationframe = fn => engine.requestAnimationFrame(fn, globalThis);
    session.oncancelanimationframe = engine.cancelAnimationFrame.bind(engine);
    this.session = session;

    delete Navigator.prototype.xr;
    window.navigator.xr = new XR.XR(window);
    window.navigator.xr.onrequestpresent = () => ({session: this.session});
    const self = this;
    window.navigator.xr.addEventListener = (_addEventListener => function addEventListener(e, fn, opts) {
      _addEventListener.apply(this, arguments);

      if (e === 'sessiongranted' && !self.seenEvents['sessiongranted']) {
        self.loadPromise.then(data => {
          self.seenEvents['sessiongranted'] = true;
          this.dispatchEvent(new MessageEvent('sessiongranted', {
            data,
          }));
        });
      } else if (e === 'schemachange' && !self.seenEvents['schemachange']) {
        self.loadPromise.then(data => {
          self.seenEvents['schemachange'] = true;
          for (const key in self.schema) {
            const value = self.schema[key];
            this.dispatchEvent(new MessageEvent('schemachange', {
              data: {
                key,
                value,
              },
            }));
          }
        });
      }
    })(window.navigator.xr.addEventListener);
    
    // window.Gamepad = Gamepad;
    window.XR = XR.XR;
    window.XRSession = XR.XRSession;
    window.XRRenderState = XR.XRRenderState;
    window.XRWebGLLayer = XR.XRWebGLLayer;
    window.XRFrame = XR.XRFrame;
    window.XRView = XR.XRView;
    window.XRViewport = XR.XRViewport;
    window.XRPose = XR.XRPose;
    window.XRViewerPose = XR.XRViewerPose;
    window.XRInputSource = XR.XRInputSource;
    window.XRRay = XR.XRRay;
    window.XRInputPose = XR.XRInputPose;
    window.XRInputSourceEvent = XR.XRInputSourceEvent;
    window.XRSpace = XR.XRSpace;
    window.XRReferenceSpace = XR.XRReferenceSpace;
    window.XRBoundedReferenceSpace = XR.XRBoundedReferenceSpace;

    Object.defineProperty(navigator, 'serviceWorker', {
      get() {},
    });

    this.loadPromise.resolve({});
  }
  /* addEventListener(e, fn, opts) {
    super.addEventListener(e, fn, opts);

    if (e === 'load' && !this.listenedLoad) {
      this.listenedLoad = true;
      this.loadPromise.then(data => {
        this.dispatchEvent(new MessageEvent('load', {
          data,
        }));
      });
    }
  } */
  setSession(session) {
    if (session) {
      GlobalContext.xrFramebuffer = session.renderState.baseLayer.framebuffer;
    } else {
      GlobalContext.xrFramebuffer = null;
    }
  }
  setMatrix(matrixArray) {
    xrOffsetMatrix.fromArray(matrixArray);
  }
  setSchema(key, value) {
    this.schema[key] = value;
    /* console.log('iframe set schema', this, key, value);
    debugger; */
    window.navigator.xr.dispatchEvent(new MessageEvent('schemachange', {
      data: {
        key,
        value,
      },
    }));
  }
}
window.xrpackage = new XRPackageManager();
})();
</script>
</body>
</html>