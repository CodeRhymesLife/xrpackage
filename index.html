<!doctype html>
<html>
<head>
<style>
body {
  margin: 0;
}
canvas {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
.buttons {
  display: flex;
  position: absolute;
  right: 30px;
  bottom: 30px;
  z-index: 1;
}
</style>
</head>
<body>
<div class=buttons>
  <input type=button id=enter-vr-button value="Enter XR">
</div>
<script type=module>
  import THREE from './three.module.js';
  window.THREE = THREE;
</script>
<script type=module>
import * as THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';
import 'https://rawcdn.githack.com/exokitxr/webpackage/655f2378d91a0496b09b1ce1a820d3fc6243cdc2/dist/wbn.js';
import {XRPackageEngine, XRPackage} from './xrpackage.js';

(async () => {

let currentSession = null;

const cubeHtml = await (async () => {
  const res = await fetch('cube.html');
  return await res.text();
})();
const cubeManifest = await (async () => {
  const res = await fetch('cube-manifest.json');
  return await res.text();
})();

const d = XRPackage.compile(
  [
    {
      url: '/',
      type: 'text/html',
      data: cubeHtml,
    },
    {
      url: '/manifest.json',
      type: 'application/json',
      data: cubeManifest,
    }
  ]
);
const p = new XRPackage(d);

const pe = new XRPackageEngine();
pe.add(p);

/* const canvas = document.createElement('canvas');
const context = canvas.getContext('webgl', {
  antialias: true,
  alpha: true,
  preserveDrawingBuffer: false,
}); */
const renderer = new THREE.WebGLRenderer({
  canvas: pe.domElement,
  context: pe.context,
  antialias: true,
  alpha: true,
  // preserveDrawingBuffer: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.autoClear = false;
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 1);

const orbitControls = new OrbitControls(camera, renderer.domElement);
// orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
scene.add(directionalLight);
const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
scene.add(directionalLight2);

const cubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(10, 1, 10);
  const material = new THREE.MeshStandardMaterial({
    color: 0x666666,
    // side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);  
  mesh.frustumCulled = false;
  return mesh;
})();
cubeMesh.position.set(0, -1/2, 0);
// cubeMesh.rotation.order = 'YXZ';
scene.add(cubeMesh);

pe.addEventListener('tick', () => {
  if (!currentSession) {
    orbitControls.update();
    pe.setCamera(camera);
  }
});

function animate(timestamp, frame) {
  renderer.state.reset();

  /* const f = (Date.now()%2000)/2000 * Math.PI*2;
  cubeMesh.rotation.x = f;
  cubeMesh.rotation.y = f;
  cubeMesh.rotation.z = f; */

  for (let i = 0; i < objects.length; i++) {
    objects[i].setMatrix(new THREE.Matrix4().compose(new THREE.Vector3(0, Math.sin((Date.now()%2000)/2000 * Math.PI*2), 0), new THREE.Quaternion(), new THREE.Vector3(1, 1, 1)));
  }

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);
renderer.xr.setSession(pe.fakeSession);

const objects = [];
document.addEventListener('dragover', e => {
  e.preventDefault();
});
const _handleUpload = async file => {
  const d = await XRPackage.compileFromFile(file);
  const p = new XRPackage(d);
  pe.add(p);

  if (/\.vrm$/.test(file.name)) {
    p.wearAvatar();
  } else {
    objects.push(p);
  }
};
document.addEventListener('drop', e => {
  e.preventDefault();

  if (e.dataTransfer.files.length > 0){
    const [file] = e.dataTransfer.files;
    _handleUpload(file);
  }
});

function onSessionStarted(session) {
  session.addEventListener('end', onSessionEnded);
  
  currentSession = session;

  // renderer.xr.setSession(session);
  pe.setSession(session);
}
function onSessionEnded() {
  currentSession.removeEventListener('end', onSessionEnded);

  currentSession = null;

  // renderer.xr.setSession(null);
  pe.setSession(null);
}
document.getElementById('enter-vr-button').addEventListener('click', e => {
  e.preventDefault();
  e.stopPropagation();
  
  if (currentSession === null) {
    navigator.xr.requestSession('immersive-vr', {
      optionalFeatures: [
        'local-floor',
        'bounded-floor',
      ],
    }).then(onSessionStarted);
  } else {
    currentSession.end();
  }
});

})();
</script>
</body>
</html>